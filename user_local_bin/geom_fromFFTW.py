#!/usr/bin/env python
# -*- coding: UTF-8 no BOM -*-
'''
 Author: Haiming Zhang
 Mail: hm.zhang@sjtu.edu.cn
 Created Time: 2016年05月28日 星期六 15时47分28秒
'''

import os,sys,math
import numpy as np
from optparse import OptionParser
from myLibs import ebsdInfo, readAngFile, readCtfFile
import damask

scriptName = os.path.splitext(os.path.basename(__file__))[0]
scriptID   = ' '.join([scriptName,damask.version])


#-------------------------------------re-------------------------------------------------------------
#                                MAIN
#--------------------------------------------------------------------------------------------------
parser = OptionParser(option_class=damask.extendableOption, usage='%prog options [file[s]]', description = """

Generate geometry description and material configuration from EBSD data in given square-gridded 'ang' file.
Two phases can be discriminated based on threshold value in a given data column.

""", version = scriptID)

parser.add_option('--microstructure',      dest='microstructure', type='int', metavar = 'int',
                  help='homogenization index for <microstructure> configuration [%default]')
parser.set_defaults(
                    microstructure = 100,
                 )
(options,filenames) = parser.parse_args()


# --- loop over input files -------------------------------------------------------------------------
if filenames == []: 
    print 'missing input files'
    exit()

for filename in filenames:

    fopen = open(filename, 'r')
    fout  = open(os.path.splitext(filename)[0] + '.geom','w')

    line = fopen.readline()

    # ---------read the data
    eulerangles = []; phases = []; grains = []; grids = []
    while line:
        conten = line.split()
        eulerangles.append( map(float, content[0:3] ))
        grids.append( map( int, content[3:6] ))
        grains.append( map( int, content[6], ))
        phases.append( map( int, content[7]) )


    eulerangles = np.array(eulerangles)
    grid = np.array(grid)
    grains = np.array(grains)
    phases = np.array(phases)

    # ---------adjust gridZmax according to the dimension
    gridXmax, gridYmax, gridZmax = [ np.max(grid[:,i]) for i in xrange(3) ]
    if options.dimension == 2: gridZmax = 1
    dataLength = gridXmax*gridYmax*gridZmax

    # ---------group the data in case of different phases
    maxPhase = np.max(phases[0:dataLength]); phaseGroup = [ [] ]*maxPhase
    grainNum = len(set(grains[0:dataLength]))
    phaseNum = len(set(phases[0:dataLength]))

    grainMap = {}; phaseMap = {}
    phaseGroup = {}
    for i,grain in enumerate(set(grains[0:dataLength])):
        grainMap[str(grain)] = i+1

    i = 0
    for phase in set(phases[0:dataLength]):
        if phase == options.phase: continue
        i = i+1
        phaseMap[str(phase)] = i

    phaseMap[str(options.phase)] = phaseNum

    phaseGroup 

    grainGroup = [ [] ]*phaseNum
    mapFFTWgrain2GEOMgrain = [ {} ]*phaseNum

    for i in xrange(dataLength):
        phaseGroup[ phases[i]-1  ].append( i )
        grainGroup[ phases[i]-1  ].append( grains[i] )

    # ---------
    for iph in xrange(maxPhase):

        # count the total number of grains in the wanted volume
        grainSet = set( grainGroup[iph] )
        # avg the euler angles in the same grains
        noGrains = len(grainSet)
        mergeEuler = np.zeros([noGrains, 3], dtype=float) 
        grainSize  = np.zeros(noGrains, dtype=int)

    avgEulerGroup = []; grainSizeGroup = []
    for i in xrange(dataLength):
        avgEuler[ grains[i] - 1 ] += eulerangles[i]
        grainSize[ grains[i] - 1 ] += 1

    for i in  noGrains:
        avgEuler[i] = avgEuler[i]/float(grainSize[i])

    for ifftw,ig in enumerate( grainSet ):
        mapFFTWgrain2GEOMgrain[str(ifftw)] = ig if options.dimension == 2 else ifftw
    noGrains = max (grainSet)

    for i in xrange(maxPhase):
        maxGrainInPhasei = max(set(grainGroup[i]))




    print 'there are %i phases in the model'%maxPhase
    for i in xrange(maxPhase):
        print 'the volume fraction of phase %i is: %f'%(i+1, )



    content = fopen.readlines()
    grid = [int(content[i].split()[1]) for i in range(5,8)]
    maxGrid = int(content[3].split()[0])
    origin = (0,0,0)
    size = [i*0.05 for i in grid]
    homogenization = 1

#-- report ---------------------------------------------------------------------------------------
    fout.write('6   header\n')
    fout.write('This model is generated by Sppark\n')
    fout.write('grid     a %s  b %s  c %s\n'%(str(grid[0]), str(grid[1]), str(grid[2]) ))
    fout.write('size     x %s  y %s  z %s\n'%(str(size[0]), str(size[1]), str(size[2]) ))
    fout.write('origin   x 0.0 y 0.0 z 0.0\n')
    fout.write('homogenization  %i\n'%homogenization)
    fout.write('microstructures %i\n'%options.microstructure)

    mapGrid2Grain = np.empty([grid[0],grid[1],grid[2]], dtype=int)
    for i in xrange(len(content)-maxGrid, len(content)):
        words = content[i].split()
        mapGrid2Grain[int(words[2]), int(words[3]), int(words[4])] = int(words[1])

    for iz in xrange(grid[2]):
        for iy in xrange(grid[1]):
            fout.write(' '.join( str(mapGrid2Grain[ix, iy, iz]) for ix in xrange(grid[0]) ) + '\n')

