#!/usr/bin/python
# -*- coding: utf-8 no BOM -*-
"""
@version: ??
@author:  Haiming Zhang
@contact: Shanghai Jiao Tong University, Shanghai, China
@email:   hm.zhang@sjtu.edu.cn
@file:    tes.py
@time:    2016/6/14 9:54
"""
import os,sys,math,string
from optparse import OptionParser
import numpy as np






fo = open('J:\\chengxu\\n10.msh', 'r')
rectangule = False
line = fo.readline()
nodesCoords = []
elementNodes = []
elementNumber = []
recountNodes = False
recountElements = False
while line:
    if recountNodes:
        if '$' not in line:
            text = line.split()
            nodesCoords.append([float(i) for i in text[1:]])
    elif recountElements:
        if '$' not in line:
            text = line.split()
            elementNodes.append([int(i) for i in text[6:]])
            elementNumber.append(int(text[4]))
    if '$Nodes' in line:
         recountNodes = True
         recountElements = False
         nodesSum = int(fo.readline())
    if '$Elements' in line:
         recountNodes = False
         recountElements = True
         elementsSum = int(fo.readline())
    line = fo.readline()
fo.close()
if len(nodesCoords) != nodesSum or len(elementNodes) != elementsSum:
    print 'This file is wrong'
nodesCoords = np.array(nodesCoords)
elementNodes = np.array(elementNodes)
elementNumber = np.array(elementNumber)
perSizeXofelement = float(nodesCoords[1,0] - nodesCoords[0,0])
if rectangule:
    perSizeYofelement = abs(nodesCoords[elementNodes[0,2],1] - nodesCoords[elementNodes[0,1],1])
else:
    perSizeYofelement = perSizeXofelement
nCoordsX = int((np.max(nodesCoords[:,0]) - np.min(nodesCoords[:,0]))/perSizeXofelement) + 1
nCoordsY = int((np.max(nodesCoords[:,1]) - np.min(nodesCoords[:,1]))/perSizeXofelement) + 1
gridPosition = np.empty([nCoordsX,nCoordsY],dtype=int)
for i in xrange(elementsSum):
    number = [int(j-1) for j in elementNodes[i, :]]
    CoordsX = []
    CoordsY = []
    for j in number:
        CoordsX.append(nodesCoords[j,0])
        CoordsY.append(nodesCoords[j,1])
    elementAverageX = np.average(CoordsX)
    elementAverageY = np.average(CoordsY)
    iCoordsX = np.round(elementAverageX / perSizeXofelement)
    iCoordsY = np.round(elementAverageY / perSizeYofelement)
    gridPosition[iCoordsX, iCoordsY] = elementNumber[i]



x = 0.5000
y = 0.5000
xCoords = np.round(x/perSizeXofelement)
yCoords = np.round(y/perSizeYofelement)
num = gridPosition[xCoords,yCoords]
if num in range(1,11):
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] in range(1,11):
                gridPosition[i,j] = 1
if num in range(11,21):
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] in range(11,21):
                gridPosition[i,j] = 11
if num in range(21,31):
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] in range(21,31):
                gridPosition[i,j] = 21
if num in range(31,41):
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] in range(31,41):
                gridPosition[i,j] = 31
if num in range(41,51):
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] in range(41,51):
                gridPosition[i,j] = 41




list = []
for i in xrange(nCoordsX):
    for j in xrange(nCoordsY):
        list.append(gridPosition[i,j])
if list.count(2) == 0:
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] != 1:
                gridPosition[i,j] = gridPosition[i,j] - 9
if list.count(12) == 0:
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] >= 12:
                gridPosition[i,j] = gridPosition[i,j] - 9
if list.count(22) == 0:
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] >= 22:
                gridPosition[i,j] = gridPosition[i,j] - 9
if list.count(32) == 0:
    for i in xrange(nCoordsX):
        for j in xrange(nCoordsY):
            if gridPosition[i,j] >= 32:
                gridPosition[i,j] = gridPosition[i,j] - 9
print gridPosition


a = open('J:\\chengxu\\n10_2.geom', 'w')
a.write('6   header\n')
a.write('This model is generated by Neper, and processed by the script xxx\n')
a.write('grid a %s b %s c 1\n'%(nCoordsX, nCoordsY))
a.write('size x 1.0 y 1.0 z 1.0\n')
a.write('origin x 0.0 y 0.0 z 0.0\n')
a.write('microstures %s\n'%(str(np.max(gridPosition))))
a.write('homogenization 1\n')
for j in xrange(nCoordsY):
    a.write(' '.join(str(gridPosition[i,j]) for i in xrange(nCoordsX) ) + '\n')
a = open('J:\\chengxu\\n10_2.mat', 'w')

ngrain= np.max(gridPosition)
a.write('#----------------#\n')
a.write('<microstructure>\n')
a.write('#----------------#\n')
for i in  xrange(ngrain):
    #phase = 2 if coarse[i] else 1]
    phase = 1
    a.write('[Grain%s]\n'%str(i))
    a.write('crystallite 1\n')
    a.write('(constituent)  phase %s texture %s fraction 1.0\n'%(str(phase), str(i)) )

a.write('\n')
a.write('#----------------#\n')
a.write('<texture>\n')
a.write('#----------------#\n')
for i in  xrange(ngrain):
    eulerangles = np.random.rand(3)*np.array([360.0, 180.0, 360.0])
    a.write('[Texture%s]\n'%str(i))
    a.write('(gauss)  phi1 %s Phi %s phi2 %s scatter 0.0 fraction 1.0\n'\
       %(str(eulerangles[0]), str(eulerangles[1]), str(eulerangles[2])) )
